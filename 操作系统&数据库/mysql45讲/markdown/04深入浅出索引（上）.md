索引的出现其实就是为了提高数据查询的效率。



## 索引的常见模型

### 哈希表

哈希表是一种以键 - 值（key-value）存储数据的结构，类似于JDK 1.7中HashMap数组+链表实现，因此哈希表这种结构适用于只有等值查询的场景。

同时哈希表不支持多个索引，因此例如覆盖索引优化就没有。



### 有序数组

有序数组在等值查询和范围查询场景中的性能就都非常优秀，可以直接利用二分查找将时间复杂度降低至O(log(N))。有序数组最大的问题在于当需要向有序数组中插入数据时，需要伴随着大量数据的搬迁，非常消耗性能。因此，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。



### B+树

B+树也是一个二叉树，对于一个平衡二叉树而言，查找速度也是O(log(N))，但是对于100W数据，树的高度就是20左右，一次查询可能需要访问 20 个数据块。磁盘随机读一个数据块需要 10 ms 左右的寻址时间，如果使用二叉树来存储，单独访问一个行可能需要 20*10 ms 的时间，效率不高。

为了解决二叉树中树高度太高问题，可以将二叉树改成“N”叉树，例如在InnoDB的整数字段索引中，这个 N 差不多是1200，这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。除此之外，树根的数据块总是在内存中，并且树的第二层数据很大概率上也是在内存中，因此采用“N”叉树的方式能够大大降低磁盘IO的平均访问次数。



## InnoDB索引模型

### 聚簇索引&非聚簇索引

每一个索引在 InnoDB 里面对应一棵 B+ 树。B+树中非叶子节点存储的是搜索方向，叶子节点存储的是整行数据或者主键的值。根据叶子节点存储的内容不同，可以分为聚簇索引和非聚簇索引：

- 聚簇索引：叶子节点存的是整行数据，主键索引就是聚簇索引
- 非聚簇索引：也叫二级索引，叶子节点内容是主键的值，通过叶子节点的值（主键）在进行一次根据主键查询数据的过程被称为 **回表** 。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，在应用中应该尽量使用主键查询。



### 索引维护

B+树为了维护索引有序性，在插入和删除新值的时候需要做必要的维护。

插入数据时，如果插入数据的位置在数据的中间位置，逻辑上后面的位置就需要向后移动，以便空出位置。比较糟糕的情况是，当前数据页在插入数据时已经满了，根据B+树算法：需要新的数据页，把之后的内容挪过去，这个过程称为 **页分裂** ，页分裂是非常好性能的操作。同时页分裂操作也降低的页的利用率，原本存放在一个页中的数据被分配到两个数据页中，数据页使用率降低50%左右。

删除数据时，当页面利用率非常低时，需要进行页的合并，页的合并是页分裂的逆过程。



### 自增主键

在一般数据库建表规范里面，通常有一个规定：表中应该有一个自增主键（not nulll  primary key auto_increment）。

这是因为当进行数据添加时，系统会自动获取当前ID最大值，并进行加1操作，正好符合递增插入场景，即每次插入新记录时，都是追加操作，不涉及到其它记录的挪动，也就不会触发页分裂操作。



考虑这样一个场景：

对于某些表，表中确实有一个字段能够唯一的代表整条数据，例如字符串类型的身份证号码，那么应该使用身份证号码作为主键还是使用自增ID作为主键呢？

由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用18 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

那么有没有什么场景就非常适合业务字段作为主键呢？

- 只有一个索引
- 该索引必须是唯一索引

典型的key-value场景，没有其它非主键索引，叶子节点上直接就是整行数据。



