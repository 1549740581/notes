讨论普通索引和唯一索引对于查询语句和更新语句的影响：



## 查询语句

对于一个简单的查询语句：`select id form t where k = 5`：

- 对于普通索引，找到第一个满足k=5的数据之后，还需要查找下一个条记录是否满足，知道碰到第一个不满足k=5的记录
- 对于唯一索引，找到第一个满足k=5的数据之后，直接停止搜索，因为唯一索引保证了唯一性

也就是说普通索引相比较于唯一索引而言，多了一次指针寻址操作和判断操作，但是对于效率的影响是微乎其微的。

InnoDB是按照数据页为单位进行读写的，也就是说，当需要读取一条记录的时候，并不是将记录本身从磁盘中读取出来，而是以页为单位，将其整体读取出来。在InnoDB中，数据页的大小默认为16KB。

也就是说，即使普通索引多了一次指针寻址操作和判断操作，但是都是在内存中完成的，更极端的情况，k=5这条记录在数据页的末尾，需要读取下一个数据页进行判断，但是这种概率是非常低的。因此，对于查询操作，普通索引和唯一索引的效率相差很低。



## 更新语句

为了说明更新语句对于普通索引和唯一索引效率的影响，需要先介绍一下 `change buffer`

当需要更新一个数据页的时候，如果数据页在内存中，那么直接更新即可。如果这个数据页还没有在内存中，在不影响数据一致性的前提下，InnoDB会将更新操作缓存到change buffer中，这样就不需要将数据更新操作直接写入到磁盘中，减少磁盘写IO。在下次查询需要访问对应的数据页时，将数据页读入到内存中，然后执行change buffer中与这个页相关的操作。

虽然它叫change buffer，但是它是可以持久化的，也就是说change buffer在内存中有拷贝，也会被直接写入到磁盘中。

将change buffer中的操作应用到原始数据页的过程，得到最新结果的过程称为 **purge**。除了访问对应数据页会触发purge操作外，系统后台会定期purge，在数据库正常关闭（shutdown）的过程中，也会存在purge操作。

什么条件下需要使用change buffer？

对于唯一性索引，所有的更新操作都需要先判断一下这个操作是否违反唯一性约束，这就需要将原始数据页读入到内存中进行判断。既然已经读入到内存中，那么直接在内存中更新会更快，没有必要使用change buffer。

因此，唯一性索引的更新并不需要使用change buffer，实际上也只有普通索引可以使用。

change buffer使用的是buffer pool的内存，不可能无限增大，可通过参数：`innodb_change_buffer_max_size`进行调节，如果这个参数为50，表示change buffer最大占用buffer pool的50%。

现在在来看更新语句对于唯一索引和普通索引的影响：

**如果待更新的目标就在内存中**

- 对于唯一索引而言，找到对应的位置，判断有没有冲突，然后更新即可
- 对于普通索引而言，找到对应的位置，直接更新

待更新的目标在内存中只会相差一个判断操作，性能影响非常小。

**如果待更新的目标不在内存中**

- 对于唯一索引而言，需要将数据页读取到内存，然后判断有没有冲突，然后更新
- 对于普通索引而言，直接将更新记录在change buffer中，然后结束

对于唯一索引而言，涉及到将数据页从磁盘中读取到内存中操作，即有磁盘IO产生，效率非常低。而使用change buffer可以明显提升性能。



## change buffer使用场景

从上面分析可以看出，change buffer不适合唯一索引，适合普通索引，那么change buffer适合所有的普通索引么？

change buffer的目的就是将记录的变化动作缓存起来，所以在一个purge操作之前，change buffer记录的变化越多（当前页面上更新次数越多），收益越大。

因此对于写多读少的业务，页面在写操作之后里面访问的概率非常小，这个时候change buffer的性能非常理想。这种业务模型常见的就是：账单类、日志类。

反过来，如果业务在更新操作之后立马会做查询，由于立马又查询操作，还是需要从访问这个数据也，因此会触发purge操作。这样随机IO的次数不会减少，反而增加了change buffer的维护代价。因此，对于这样的场景，应该关闭change buffer。