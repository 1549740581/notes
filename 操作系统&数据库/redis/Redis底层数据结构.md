参考文章：https://zhuanlan.zhihu.com/p/38380467



# 数据结构

## 简单动态字符串（SDS）

Redis 没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（simple dynamic string SDS）的抽象类型，并将SDS用作Redis 的默认字符串表示。除了用来保存字符串以外，SDS还被用作AOF模块中的AOF缓冲区。

SDS相比ANSI C改进：

-   c中获取字符串长度需要O(n)复杂度，SDS维护了len变量，记录已占用的空间的长度
-   缓冲区溢出：c中在拓展字符串时，首先O(n)获取到字符串长度，然后需要手动重新分配内存，如果忘记重新分配内存，会导致缓冲区溢出。SDS在进行字符串拼接时，会预先检查SDS是否足够，如果不够先拓展空间，在执行拼接操作
-   减少字符串修改内存重新分配的次数：c在进行字符串拓展时可能出现缓冲区溢出，在收缩时可能出现内存泄露。SDS在拓展时采用的是预分配策略：扩容时现将SDS长度修改成N，然后将未使用的空间（由free记录）同样修改成N，如果再次进行扩容，因为内存足够就不需要再次申请内存。通过预分配策略，SDS将连续增长N次字符串所需要的内存分配次数从必定N次，降低到最多N次。
-   内存惰性释放：SDS提供了相应的API，可以在需要的时候，将SDS剩余的空间通过惰性释放。
-   二进制安全：传统的c是以\0作为字符串结尾，这就限制它只能保存文本文件，对于图片、音频等其它格式文件就可能出现二进制不安全问题。SDS是通过len属性来判断字符串是否结束，不存在二进制安全问题。

```c
/*  
 * 保存字符串对象的结构  
 */  
struct sdshdr {  
    // buf 中已占用空间的长度  
    int len;  

    // buf 中剩余可用空间的长度(初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现)-预分配  
    int free;  

    // 数据空间  
    char buf[];  
};
```



## 链表

**顺序存储对象信息，有用于缓存链表长度的属性，在插入删除对象功能中有良好性能，避免环的产生**
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。链表在Redis 中的应用非常广泛，比如**列表键的底层实现之一就是链表**。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis 就会使用链表作为列表键的底层实现。

-   使用双端链表，head节点的pre指针和tail节点的next指针指向NULL，避免环产生
-   链表中维护一个len计数器，O(1)时间复杂度获取链表长度
-   多态：链表节点使用void*万能指针来保存节点值，并且通过dup、free、match三个属性为节点值设置特定类型

listNode源码：

```c
typedef struct listNode{
      struct listNode *prev;
      struct listNode * next;
      void * value;  
}
```

list源码：
```c
typedef struct list{
    //表头节点
    listNode  * head;
    //表尾节点
    listNode  * tail;
    //链表长度
    unsigned long len;
    //节点值复制函数
    void *(*dup) (void *ptr);
    //节点值释放函数
    void (*free) (void *ptr);
    //节点值对比函数
    int (*match)(void *ptr, void *key);
}
```



## 字典

**key-value 存储方式，通过hash值计算，判断key的存储，当容量过大，会通过rehash重新分配字典大小**
字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。在字典中，一个键（key）可以和一个值（value）进行关联，字典中的每个键都是独一无二的。在C语言中，并没有这种数据结构，但是Redis 中构建了自己的字典实现。

字典使用的哈希表源码：

```c
typedef struct dictht {
   //哈希表数组
   dictEntry **table;
   //哈希表大小
   unsigned long size;

   //哈希表大小掩码，用于计算索引值
   unsigned long sizemask;
   //该哈希表已有节点的数量
   unsigned long used;
}
```

哈希表每个节点源码：

```c
typeof struct dictEntry{
   //键
   void *key;
   //值
   union{
      void *val;
      uint64_tu64;
      int64_ts64;
   }
   struct dictEntry *next;

}
```

Redis中解决hash冲突使用的是链地址法。

Rehash过程：

随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成。

维护两个hash表，拓展和缩容时大小都是2的整数次幂，当需要rehash时，将一个hash表中的数据转移到另一个hash表，并重新计算索引值。

渐进式rehash：

在进行拓展或者压缩的时候，可以直接将所有的键值对rehash 到ht[1]中，这是因为数据量比较小。在实际开发过程中，这个rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。

-   为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
-   维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始
-   在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一
-   当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束

hash表扩容原则：

-   服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1
-   服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5



## 跳表

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。

跳表在redis中两个地方使用到：

-   sortedset的key
-   集群节点中内部数据结构

跳表是一种分层链表的数据结构，主要由zskiplist和zskiplistNode组成：

```c
typedef struct zskiplistNode{
　　　//层
     struct zskiplistLevel{
　　　　　//前进指针
        struct zskiplistNode *forward;
　　　　//跨度
        unsigned int span;
    } level[];
　　//后退指针
    struct zskiplistNode *backward;
　　//分值
    double score;
　　//成员对象
    robj *obj;
}

typedef struct zskiplist {
     //表头节点和表尾节点
     structz skiplistNode *header,*tail;
     //表中节点数量
     unsigned long length;
     //表中层数最大的节点的层数
     int level;

}zskiplist;
```

补充：

-   每个跳表的层高都是1-32之间的随机数
-   同一个跳表中，多个节点可以包含相同的分数，但每个节点的对象必须是唯一的
-   节点按照分数值从大到小排序，如果分数相同，则按照对象大小排序



## 整数集合

整数集合是集合建的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合intset作为集合的底层实现。其实整数集合就是一个特殊的集合，里面存放的都是整数，并且数据量不能太大。

```c
typedef struct intset{
    //编码方式
    uint32_t enconding;
   // 集合包含的元素数量
    uint32_t length;
    //保存元素的数组    
    int8_t contents[];
}
```

intset 在默认情况下会帮我们设定整数集合中的编码方式，但是当存入的整数不符合整数集合中的编码格式时，就需要使用到Redis 中的升级策略来解决，注意Redis只支持升级策略，不支持降级策略：

-   根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
-   将底层数组现有的所有元素都转换成新的编码格式，重新分配空间
-   将新元素加入到底层数组中



## 压缩列表

压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的**顺序型**（sequential）数据结构。格式：`zlbytes-zltail-zllen-entry1-...-entryN-zlend`

-   zlbytes：4字节， 记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。
-   zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。
-   zllen： 记录了压缩列表包含的节点数量，当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。

-   entry：  压缩列表包含的各个节点，节点的长度由节点保存的内容决定



# 对象

## 字符串对象

如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值

embstr  编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr  结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr  编码则通过调用一次内存分配函数来分配一块连续的空间。

-   embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次
-   释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数
-   embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势



## 列表对象

列表对象的编码可以是ziplist或者linkedlist，当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：

-   列表对象保存的所有字符串元素的长度都小于 64 字节
-   列表对象保存的元素数量小于 512 个

不满足上述条件时，使用linkedlist编码，上述两个值可以修改，在list-max-ziplist-value选项中。



## 哈希对象

哈希对象的编码可以是ziplist或者hashtable。

ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存键的压缩列表节点推入到压缩列表尾部，然后将保存了值的压缩列表节点推入压缩列表尾部，因此：

-   保存同一个键值对的两个节点总是紧挨着，键在前，值在后
-   先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向

当哈希对象可以同时满足以下两个条件时， 哈希：对象使用 ziplist 编码：

-   哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节
-   哈希对象保存的键值对数量小于 512 个

不能满足这两个条件的哈希对象需要使用 hashtable 编码，上述值也可以通过hash-max-ziplist-value值来修改。



## 集合对象

集合对象的编码可以是 intset 或者 hashtable 。

-   intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面
-   hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 

当集合对象同时满足以下两个条件时，对象使用intset编码：

-   集合对象保存的所有元素都是整数值
-   集合对象保存的元素数量不超过 512 个

不能满足这两个条件的集合对象需要使用 hashtable 编码，上述值可以通过set-max-intset-entries选项修改。



## 有序集合对象

有序集合编码可以通过ziplist和skiplist。

-   ziplist 编码的有序集合对象使用压缩列表作为底层实现每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向
-   skiplist 编码的有序集合对象使用 zset 结构作为底层实现一个 zset 结构同时包含一个字典和一个跳跃表



## 内存回收

因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收，对象的引用计数信息会随着对象的使用状态而不断变化：

-   在创建一个新对象时， 引用计数的值会被初始化为 1 
-   当对象被一个新程序使用时， 它的引用计数值会被增一
-   当对象不再被一个程序使用时， 它的引用计数值会被减一

-   当对象的引用计数值变为 0 时， 对象所占用的内存会被释放

对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。



## 对象共享

除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：

-   将数据库键的值指针指向一个现有的值对象

-   将被共享的值对象的引用计数增一

目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。