## 图的基本表示
一个图由最基本的两个元素构成：
> 1. 顶点 Vertex
> 2. 边 Edge

## 图的分类
按照图中边是否有方向、是否有权值可以分为四类：
- 无向无权图：地铁、好友关系
- 无向有权图：城市之间路径
- 有向无权图：粉丝关注问题
- 有向有权图

## 无向无权图
- 自环边：顶点自己到自己形成一个环
- 平行边：顶点a、b之间存在a到b的边，已存在b到a的边
- 简单图：没有自环边和平行边的无向无权图成为简单图

## 几个概念
- 连通分量：相互连接的点构成一个联通分量
- 一张图所有顶点并不一定都是相互连接的，即一个图可能包含多个联通分量
- 一个图可以没有环，树是一种无环图，注意在图论中讨论树时，树的根节点是任意的
- 无环图不一定是树，因为无环图可以包含多个联通分量，多个联通分量不能构成树的形状
- 一个联通的无环图一定是一棵树
- 联通图可以生成树，生成树是包含所有顶点的树，但是并不一定包含所有的边
- 生成树的边数一定是V-1，V为顶点个数，如果大于V-1会形成环，如果小于V-1会有多个联通分量，不会形成树
- 包含所有顶点，并且边数是V-1，形成的图不一定是联通图的生成树，因为可能有多个联通分量的出现
- 一个图不一定有生成树，一个联通图一定有生成树，一个图一定有联通森林
- 顶点的度（degree）：对于一个无向图，度就是这个顶点相邻的边数

## 稀疏图和稠密图
稀疏图和稠密图：稀疏和稠密针对的是边的个数，稀疏和稠密是相对的概念，没有明确界限，实际场景中大多数场景都是稀疏图：
- 如果某个图中有1000个节点，而每个节点的度为3，则总共的边数为：1000*3/2 = 1500
- 如果某个图中有1000个节点，而每个节点的度为999，则总共的边数为：1000*999/2=4995000，也叫完全图

## 邻接矩阵
邻接矩阵定义：
- 实际上是一个方阵，A[i][j]=1，表示顶点i和顶点j是相邻的
- 对于简单图而言，主对角线上的值都为0，即A[i][i]=0
- 对于无向图而言，邻接矩阵关于主对角线对称，即A[i][j]==A[j][i]

邻接矩阵的问题：
对于实际场景中，绝大数图都是稀疏图，但是邻接矩阵的空间复杂度是O(V^2)，查找相邻节点时间复杂度为O(V)，有没有可能将查找相邻节点的时间复杂度优化到接近O(degree(v))呢？

## 邻接表
邻接表定义：
- 邻接表是一个数组，数组中每个元素是一个链表
- 数组中的每个链表存储的是当前节点的相邻节点

邻接表的问题：
当进行构造邻接表时，如果需要判断平行边的存在（快速判重问题），时间复杂度为O(E*V)。同时，判断两个节点是否相邻时，时间复杂度为O(V)。

## 邻接集合
可以使用TreeSet或者HashSet来代替邻接表中链表实现方案，TreeSet的优势在于元素有序，方便之后代码的调试，同时占用内存较少。HashSet的优势在于查找速度相比于TreeSet的O(log(V))，直接是O(1)的，效率高。



|                 | 空间   | 建图时间               | 判断两个节点是否连通     | 查找节点所有临边      | 特点                                                   |
| --------------- | ------ | ---------------------- | ------------------------ | --------------------- | ------------------------------------------------------ |
| 邻接矩阵        | O(V^2) | O(E)                   | O(1)                     | O(V)                  | 空间消耗过大，查找临边时间复杂度过高                   |
| 邻接表          | O(E+V) | O(E)，如果查重：O(E*V) | O(degree(V))     -> O(V) | O(degree(V))  -> O(V) | 建图时间在需要判断平行边情况下复杂度待优化             |
| 邻接集合TreeSet | O(E+V) | O(E*log(V))            | O(log(V))                | O(degree(V))  -> O(V) | 给定节点的相邻节点是有序的，方便调试，log(V)性能不错   |
| 邻接集合HashSet | O(E+V) | O(E)                   | O(1)                     | O(degree(V))  -> O(V) | 性能极高，但是相对TreeSet占用内存稍高，debug调试不方便 |

